def CALCB(NVAC,KGAS,LGAS,ELECEN,ISHELL):
	# IMPLICIT #real*8(A-H,O-Z)
	# IMPLICIT #integer*8(I-N)
	# CHARACTER*6 SCR(17),SCR1(17)
	# COMMON/PRIM4/MSUM1,MCOMP1,MRAYL1,MPAIR1,MPHOT1,MVAC1
	# COMMON/GENCAS/ELEV[17,79],NSDEG(17),AA[17],BB[17],SCR,SCR1
	# COMMON/MIXC/PRSH(6,3,17,17),ESH(6,3,17),AUG(6,3,17,17,17),RAD[6,3,17,17],PRSHBT(6,3,17),IZ[6,3],INIOCC(6,3,17),ISHLMX(6,3),AMZ[6,3]
	# COMMON/UPD/NOCC(6,3,17),AUGR(6,3,17,17,17),RADR(6,3,17,17)
	# COMMON/CALCASB/IONSUM(10),IFLSUM(10),ESTORE(10,28),EPHOTON(10,28),DRXE(10,28),DRYE(10,28),DRZE(10,28),DRX(10,28),DRY(10,28),DRZ[10,28]
	#COMMON/PRIM4/
	global MSUM1,MCOMP1,MRAYL1,MPAIR1,MPHOT1,MVAC1
	#COMMON/GENCAS/
	global ELEV#[17,79]
	global NSDEG#(17)
	global AA#[17]
	global BB#[17]
	global SCR,SCR1
	#COMMON/MIXC/
	global PRSH#(6,3,17,17)
	global ESH#(6,3,17)
	global AUG#(6,3,17,17,17)
	global RAD#[6,3,17,17]
	global PRSHBT#(6,3,17)
	global IZ#[6,3]
	global INIOCC#(6,3,17)
	global ISHLMX#(6,3)
	global AMZ#[6,3]
	#COMMON/UPD/
	global NOCC#(6,3,17)
	global AUGR#(6,3,17,17,17)
	global RADR#(6,3,17,17)
	#COMMON/CALCASB/
	global IONSUM#(10)
	global IFLSUM#(10)
	global ESTORE#(10,28)
	global EPHOTON#(10,28)
	global DRXE#(10,28)
	global DRYE#(10,28)
	global DRZE#(10,28)
	global DRX#(10,28)
	global DRY#(10,28)
	global DRZ#[10,28]
	
	#DIMENSION 
	TEMP=[0 for x in range(17)]
	TEMP1=[0 for x in range(289)]
	#
	# CALCULATE CASCADE IN GAS KGAS AND MOLECULAR COMPONENT LGAS
	# WITH INTIAL ENERGY DEPOSIT ELECEN AND SHELL VACANCY CREATED AT ISHELL
	#
	# INITIAL PHOTON DIRECTION  DRX, DRY AND DRZ
	DRXINIT=DRXE[NVAC][1]
	DRYINIT=DRYE[NVAC][1]
	DRZINIT=DRZE[NVAC][1]
	ISHELLST=ISHELL
	def GOTO100():
		ELEFT=ELECEN
		ISHELL=ISHELLST
		API=numpy.arccos(-1.00)
		TWOPI=2.00*API
		ISECOND=1
		IFIRST=0
		# SET STARTING ARRAY NOCC EQUAL TO INIOCC
		for I in range(1,17):
			NOCC[KGAS][LGAS][I]=INIOCC[KGAS][LGAS][I]
		# PHOTONS
		IONSUM[NVAC]=1
		IFLSUM[NVAC]=0
		# STORE INITIAL PHOTOELECTRON ENERGY AND ANGLE
		ESTORE[NVAC][1]=ELECEN-ELEV[ISHELL,IZ[KGAS][LGAS]]
		ELECN=ESTORE[NVAC][1]
		ELEFT=ELEFT-ESTORE[NVAC][1]
		NOCC[KGAS][LGAS][ISHELL]=NOCC[KGAS][LGAS][ISHELL]-1  
		#    ENTRY FOR COMPTON ELECTRON.....
		if(NVAC <= MCOMP1):
			#    IF COMPTON EVENT ELECTRON ANGLE FROM COMPTON (ALREADY STORED)
			pass
			# endif
		else:
			# USE PHOTOELCTRON ANGULAR DISTRIBUTION
			APE=AA[ISHELL]
			BPE=BB[ISHELL]
			ANGGEN(APE,BPE,THET)
			if(THET < 0.0):
				THET=THET+API
			R3=DRAND48(RDUM)
			PHI=TWOPI*R3
			# INITIAL PHOTON DIRECTION  DRXINIT, DRYINIT AND DRZINIT
			DRCOS(DRXINIT,DRYINIT,DRZINIT,THET,PHI,DRXX,DRYY,DRZZ)
			DRXE[NVAC][1]=DRXX
			DRYE[NVAC][1]=DRYY
			DRZE[NVAC][1]=DRZZ
		def GOTO4():
			# CHECK FOR ELECTRON SHAKEOFF
			ICON=1
			IFIRST=IFIRST+1
			if(IFIRST > 1):
				ELECN=ESTORE[NVAC][IONSUM[NVAC]]
			SHAKE(ISHELL,ELECN,KGAS,LGAS,ESHK,ICON,IFIRST,JVAC)
			#  CALCULATE ENERGY OF ELECTRON
			if(JVAC == 0):
				GOTO2()
			if(IFIRST == 1):
				# INITIAL ELECTRON + SHAKEOFF
				ELECN=ELECN-ESHK-ELEV[JVAC,IZ[KGAS][LGAS]]
				# PRIMARY ELECTRON
				ESTORE[NVAC][IONSUM[NVAC]]=ELECN
			# endif
			if(IFIRST != 1):
				ESTORE[NVAC][IONSUM[NVAC]]=ESTORE[NVAC][IONSUM[NVAC]]-ESHK-ELEV[JVAC,IZ[KGAS][LGAS]]
			# endif
			IONSUM[NVAC]=IONSUM[NVAC]+1
			# MAXIMUM ION CHARGE STATE =28
			if(IONSUM[NVAC]> 28) :
				#WRITE(6,99) IONSUM[NVAC]   #error
				print(' WARNING ION CHARGE LIMITED TO 28+ IN THIS VERSION') 
				sys.exit()
			# endif
			# SHAKE ELECTRON
			ESTORE[NVAC][IONSUM[NVAC]]=ESHK
			ELEFT=ELEFT-ESHK-ELEV[JVAC,IZ[KGAS][LGAS]]
			if(ELEFT < 0.0):
				GOTO100()
			# RANDOM EMISSION DIRECTION
			R3=DRAND48(RDUM)
			THET=numpy.arccos(1.0-2.0*R3)
			R3=DRAND48(RDUM)
			PHI=TWOPI*R3
			DRXE[NVAC][IONSUM[NVAC]]=numpy.sin(THET)*numpy.cos(PHI)
			DRYE[NVAC][IONSUM[NVAC]]=numpy.sin(THET)*numpy.sin(PHI)
			DRZE[NVAC][IONSUM[NVAC]]=numpy.cos(THET)
			def GOTO2(): 
				UPDATE(KGAS,LGAS,ISHELL)
				#  CHOOSE FLUORESCENCE OR AUGER TRANSITION
				TSUM=0.0
				for I in range(1,17):
					TSUM=TSUM+RADR[KGAS][LGAS][ISHELL][I]
					for J in range(1,17):
						TSUM=TSUM+AUGR[KGAS][LGAS][ISHELL][I][J]
				# NO MORE TRANSITIONS POSSIBLE
				if(TSUM == 0.0):
					return  
				# NORMALISE TO 1.0
				for I in range(1,17):
					RADR[KGAS][LGAS][ISHELL][I]=RADR[KGAS][LGAS][ISHELL][I]/TSUM
					for J in range(1,17):
						AUGR[KGAS][LGAS][ISHELL][I][J]=AUGR[KGAS][LGAS][ISHELL][I][J]/TSUM
				# CREATE CUMULATIVE SUM ARRAY
				TEMP[1]=RADR[KGAS][LGAS][ISHELL][1]
				for I in range(2,17):
					TEMP[I]=RADR[KGAS][LGAS][ISHELL][I]+TEMP[I-1]
				TEMP1[1]=AUGR[KGAS][LGAS][ISHELL][1][1]
				for I in range(2,17):
					TEMP1[I]=AUGR[KGAS][LGAS][ISHELL][I][1]+TEMP1[I-1]
				for J in range(1,16):
					for I in range(1,17):
						TEMP1[I+(J*17)]=AUGR[KGAS][LGAS][ISHELL][I][(J+1)]+TEMP1[I+(J*17)-1]
				# FIND FLUORESCENCE OR AUGER TRANSITION
				R1=DRAND48(RDUM)
				for I in range(1,17):
					if(R1 < TEMP[I]):
						# STORE PHOTON ENERGY AND ANGLE : UPDATE NOCC
						IFLSUM[NVAC]=IFLSUM[NVAC]+1
						EPHOTON[NVAC][IFLSUM[NVAC]]=ELEV[ISHELL,IZ[KGAS][LGAS]]-ELEV[I,IZ[KGAS][LGAS]]
						ELEFT=ELEFT-abs(EPHOTON[NVAC][IFLSUM[NVAC]])
						if(ELEFT < 0.0):
							GOTO100()
						# RANDOM EMISSION DIRECTION
						R3=DRAND48(RDUM)
						THET=numpy.arccos(1.0-2.0*R3)
						R3=DRAND48(RDUM)
						PHI=TWOPI*R3
						# CALC DIRECTION COSINES OF FLUORESCENCE
						DRX[NVAC][IFLSUM[NVAC]]=numpy.sin(THET)*numpy.cos(PHI)
						DRY[NVAC][IFLSUM[NVAC]]=numpy.sin(THET)*numpy.sin(PHI)
						DRZ[NVAC][IFLSUM[NVAC]]=numpy.cos(THET)
						#   
						NOCC[KGAS][LGAS][ISHELL]=NOCC[KGAS][LGAS][ISHELL]+1
						NOCC[KGAS][LGAS][I]=NOCC[KGAS][LGAS][I]-1
						# FIND LOWEST VACANCY
						VACANCY(KGAS,LGAS,ISHELL,ILAST)
						if(ILAST == 1):
							# NO MORE TRANSITIONS POSSIBLE
							return    
						# endif
						GOTO2()
					# endif 
			GOTO2()
			flag116=1
			while(flag116):
				flag116=0
				R2=R1-TEMP(17)
				for J in range(1,17):
					if(flag116==1):
						break
					for I in range(1,17):
						if(R2 < TEMP1[I+((J-1)*17)]) :
							# AUGER OR COSTER KRONIG  
							# STORE EJECTED ELECTRON AND UPDATE NOCC
							ETEMP=ELEV[ISHELL,IZ[KGAS][LGAS]]-(ELEV[I,IZ[KGAS][LGAS]]+ELEV[I,IZ[KGAS][LGAS]+1])*0.5-(ELEV[J,IZ[KGAS][LGAS]]+ELEV[J,IZ[KGAS][LGAS]+1])*0.5
							if(ETEMP < 0.0):
								# DO NOT ALLOW NEGATIVE ENERGY TRANSITIONS
								flag117=1
								while (flag117):
									flag117=0
									R1=DRAND48(RDUM)
									if(R1 < TEMP(17)):
										flag117=1
								flag116=1
								break
							# endif
							IONSUM[NVAC]=IONSUM[NVAC]+1
							if(IONSUM[NVAC]>28): 
								print(' IONSUM LIMITED TO 28 IN THIS VERSION IONSUM=',IONSUM[NVAC],' IN CALCB')
								sys.exit()
							# endif
							ESTORE[NVAC][IONSUM[NVAC]]=ETEMP
							ELEFT=ELEFT-abs(ETEMP)
							if(ELEFT < 0.0):
								GOTO100()
							# RANDOM EMISSION DIRECTION
							R3=DRAND48(RDUM)
							THET=numpy.arccos(1.0-2.0*R3)
							R3=DRAND48(RDUM)
							PHI=TWOPI*R3
							DRXE[NVAC][IONSUM[NVAC]]=numpy.sin(THET)*numpy.cos(PHI)
							DRYE[NVAC][IONSUM[NVAC]]=numpy.sin(THET)*numpy.sin(PHI)
							DRZE[NVAC][IONSUM[NVAC]]=numpy.cos(THET)
							NOCC[KGAS][LGAS][ISHELL]=NOCC[KGAS][LGAS][ISHELL]+1
							NOCC[KGAS][LGAS][I]=NOCC[KGAS][LGAS][I]-1
							NOCC[KGAS][LGAS][J]=NOCC[KGAS][LGAS][J]-1
							# FIND LOWEST VACANCY
							VACANCY(KGAS,LGAS,ISHELL,ILAST)
							if(ILAST == 1):
								# NO MORE TRANSITIONS POSSIBLE
								return
							# endif
							GOTO4()
		GOTO4()				# endif
	GOTO100()
	print(' ERROR IN CASCADE 0 def CALCB') 
	sys.exit() 
	# end